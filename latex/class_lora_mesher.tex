\hypertarget{class_lora_mesher}{}\doxysection{Lora\+Mesher Class Reference}
\label{class_lora_mesher}\index{LoraMesher@{LoraMesher}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_lora_mesher_1_1network_node}{network\+Node}}
\item 
struct \mbox{\hyperlink{struct_lora_mesher_1_1routable_node}{routable\+Node}}
\item 
struct \mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{user\+Packet}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_lora_mesher_ac3807f4ae5e6fa40e7e403df040e69ca}{init}} (void($\ast$receiver\+Function)(void $\ast$))
\begin{DoxyCompactList}\small\item\em Initialize the Lora Mesher object. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_lora_mesher_ac6387d236746f74a845167907668f5de}\label{class_lora_mesher_ac6387d236746f74a845167907668f5de}} 
{\bfseries $\sim$\+Lora\+Mesher} ()
\begin{DoxyCompactList}\small\item\em Destroy the Lora Mesher. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_lora_mesher_ac600ecb52b71892e12bb7e1889be6de8}{create\+Packet\+And\+Send}} (uint16\+\_\+t dst, T $\ast$payload, uint8\+\_\+t payload\+Size)
\begin{DoxyCompactList}\small\item\em Create a Packet And Send it. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_lora_mesher_a129d8a250d3b7dce85f735d6313fb256}{send\+Reliable\+Packet}} (uint16\+\_\+t dst, uint8\+\_\+t $\ast$payload, uint32\+\_\+t payload\+Size)
\begin{DoxyCompactList}\small\item\em Send the payload reliable. It will wait for an ACK back from the destination to send the next packet. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_lora_mesher_afd00da774300a17399cbee5941ebc934}{send\+Reliable}} (uint16\+\_\+t dst, T $\ast$payload, uint32\+\_\+t payload\+Size)
\begin{DoxyCompactList}\small\item\em Send the payload reliable. It will wait for an ack of the destination. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{class_lora_mesher_af02b008ec573f4c0f0b3ea7a31e0982e}{get\+Received\+Queue\+Size}} ()
\begin{DoxyCompactList}\small\item\em Returns the number of packets inside the received packets queue. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\\mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{user\+Packet}}$<$ T $>$ $\ast$ \mbox{\hyperlink{class_lora_mesher_a54e0edeaf306b3647325bd362982ee8d}{get\+Next\+User\+Packet}} ()
\begin{DoxyCompactList}\small\item\em Get the Next User Packet. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\size\+\_\+t \mbox{\hyperlink{class_lora_mesher_ae12b570f2c65008f93704b2d2236e8f8}{get\+Payload\+Length}} (\mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{user\+Packet}}$<$ T $>$ $\ast$p)
\begin{DoxyCompactList}\small\item\em Get the payload length in number of T. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_lora_mesher_a1ec79ff9602ef2b990324ac8df5900e8}\label{class_lora_mesher_a1ec79ff9602ef2b990324ac8df5900e8}} 
void {\bfseries print\+Routing\+Table} ()
\begin{DoxyCompactList}\small\item\em Prints the actual routing table in the log. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_lora_mesher_ab70a80c723b4a610b897fd8f523a3359}{routing\+Table\+Size}} ()
\begin{DoxyCompactList}\small\item\em Returns the routing table size. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_lora_mesher_ae1500aa34fee29223f7e26552ed15f10}{has\+Addres\+Routing\+Table}} (uint16\+\_\+t address)
\begin{DoxyCompactList}\small\item\em Returns if address is inside the routing table. \end{DoxyCompactList}\item 
uint16\+\_\+t \mbox{\hyperlink{class_lora_mesher_a59ed7f736562ef6962047ce4ef622dd2}{get\+Next\+Hop}} (uint16\+\_\+t dst)
\begin{DoxyCompactList}\small\item\em Get the Next Hop address. \end{DoxyCompactList}\item 
uint16\+\_\+t \mbox{\hyperlink{class_lora_mesher_a1cd59cbd716f9e11ca993798f79d7a41}{get\+Local\+Address}} ()
\begin{DoxyCompactList}\small\item\em Get the Local Address. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{class_lora_mesher}{Lora\+Mesher}} \& \mbox{\hyperlink{class_lora_mesher_a7b71856ecfaa71d694fb008c0ba4642a}{get\+Instance}} ()
\begin{DoxyCompactList}\small\item\em Get the \mbox{\hyperlink{class_lora_mesher}{Lora\+Mesher}} Instance. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\static void \mbox{\hyperlink{class_lora_mesher_a2d6e1298189108bbc07ff5621e4d667a}{delete\+Packet}} (\mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{user\+Packet}}$<$ T $>$ $\ast$p)
\begin{DoxyCompactList}\small\item\em Delete the packet from memory. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_lora_mesher_a27e10ff173408bfa52063d6bfef2d60a}\label{class_lora_mesher_a27e10ff173408bfa52063d6bfef2d60a}} 
\mbox{\hyperlink{struct_lora_mesher_1_1routable_node}{routable\+Node}} {\bfseries routing\+Table} \mbox{[}RTMAXSIZE\mbox{]}
\begin{DoxyCompactList}\small\item\em Routing table array. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_lora_mesher_ac600ecb52b71892e12bb7e1889be6de8}\label{class_lora_mesher_ac600ecb52b71892e12bb7e1889be6de8}} 
\index{LoraMesher@{LoraMesher}!createPacketAndSend@{createPacketAndSend}}
\index{createPacketAndSend@{createPacketAndSend}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{createPacketAndSend()}{createPacketAndSend()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Lora\+Mesher\+::create\+Packet\+And\+Send (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{dst,  }\item[{T $\ast$}]{payload,  }\item[{uint8\+\_\+t}]{payload\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Create a Packet And Send it. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em dst} & Destination \\
\hline
{\em payload} & Payload of type T \\
\hline
{\em payload\+Size} & Length of the payload in T \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_lora_mesher_a2d6e1298189108bbc07ff5621e4d667a}\label{class_lora_mesher_a2d6e1298189108bbc07ff5621e4d667a}} 
\index{LoraMesher@{LoraMesher}!deletePacket@{deletePacket}}
\index{deletePacket@{deletePacket}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{deletePacket()}{deletePacket()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
static void Lora\+Mesher\+::delete\+Packet (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{user\+Packet}}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Delete the packet from memory. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type of packet \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & Packet to delete \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_lora_mesher_a7b71856ecfaa71d694fb008c0ba4642a}\label{class_lora_mesher_a7b71856ecfaa71d694fb008c0ba4642a}} 
\index{LoraMesher@{LoraMesher}!getInstance@{getInstance}}
\index{getInstance@{getInstance}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{getInstance()}{getInstance()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_lora_mesher}{Lora\+Mesher}} \& Lora\+Mesher\+::get\+Instance (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



Get the \mbox{\hyperlink{class_lora_mesher}{Lora\+Mesher}} Instance. 

\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_lora_mesher}{Lora\+Mesher}}\& 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lora_mesher_a1cd59cbd716f9e11ca993798f79d7a41}\label{class_lora_mesher_a1cd59cbd716f9e11ca993798f79d7a41}} 
\index{LoraMesher@{LoraMesher}!getLocalAddress@{getLocalAddress}}
\index{getLocalAddress@{getLocalAddress}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{getLocalAddress()}{getLocalAddress()}}
{\footnotesize\ttfamily uint16\+\_\+t Lora\+Mesher\+::get\+Local\+Address (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get the Local Address. 

\begin{DoxyReturn}{Returns}
uint16\+\_\+t Address 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lora_mesher_a59ed7f736562ef6962047ce4ef622dd2}\label{class_lora_mesher_a59ed7f736562ef6962047ce4ef622dd2}} 
\index{LoraMesher@{LoraMesher}!getNextHop@{getNextHop}}
\index{getNextHop@{getNextHop}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{getNextHop()}{getNextHop()}}
{\footnotesize\ttfamily uint16\+\_\+t Lora\+Mesher\+::get\+Next\+Hop (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{dst }\end{DoxyParamCaption})}



Get the Next Hop address. 


\begin{DoxyParams}{Parameters}
{\em dst} & address of the next hop \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
uint16\+\_\+t address of the next hop 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lora_mesher_a54e0edeaf306b3647325bd362982ee8d}\label{class_lora_mesher_a54e0edeaf306b3647325bd362982ee8d}} 
\index{LoraMesher@{LoraMesher}!getNextUserPacket@{getNextUserPacket}}
\index{getNextUserPacket@{getNextUserPacket}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{getNextUserPacket()}{getNextUserPacket()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{user\+Packet}}$<$ T $>$ $\ast$ Lora\+Mesher\+::get\+Next\+User\+Packet (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get the Next User Packet. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type to be converted \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
user\+Packet$<$\+T$>$$\ast$ 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lora_mesher_ae12b570f2c65008f93704b2d2236e8f8}\label{class_lora_mesher_ae12b570f2c65008f93704b2d2236e8f8}} 
\index{LoraMesher@{LoraMesher}!getPayloadLength@{getPayloadLength}}
\index{getPayloadLength@{getPayloadLength}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{getPayloadLength()}{getPayloadLength()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
size\+\_\+t Lora\+Mesher\+::get\+Payload\+Length (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{user\+Packet}}$<$ T $>$ $\ast$}]{p }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Get the payload length in number of T. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & Type to be converted \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em p} & user packet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
size\+\_\+t size in number of T 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lora_mesher_af02b008ec573f4c0f0b3ea7a31e0982e}\label{class_lora_mesher_af02b008ec573f4c0f0b3ea7a31e0982e}} 
\index{LoraMesher@{LoraMesher}!getReceivedQueueSize@{getReceivedQueueSize}}
\index{getReceivedQueueSize@{getReceivedQueueSize}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{getReceivedQueueSize()}{getReceivedQueueSize()}}
{\footnotesize\ttfamily size\+\_\+t Lora\+Mesher\+::get\+Received\+Queue\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns the number of packets inside the received packets queue. 

\begin{DoxyReturn}{Returns}
size\+\_\+t
\end{DoxyReturn}
End Region Packet Region Packet\+Queue \mbox{\Hypertarget{class_lora_mesher_ae1500aa34fee29223f7e26552ed15f10}\label{class_lora_mesher_ae1500aa34fee29223f7e26552ed15f10}} 
\index{LoraMesher@{LoraMesher}!hasAddresRoutingTable@{hasAddresRoutingTable}}
\index{hasAddresRoutingTable@{hasAddresRoutingTable}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{hasAddresRoutingTable()}{hasAddresRoutingTable()}}
{\footnotesize\ttfamily bool Lora\+Mesher\+::has\+Addres\+Routing\+Table (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{address }\end{DoxyParamCaption})}



Returns if address is inside the routing table. 


\begin{DoxyParams}{Parameters}
{\em address} & Addres you want to check if is inside the routing table \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true If the address is inside the routing table 

false If the addres is not inside the routing table 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lora_mesher_ac3807f4ae5e6fa40e7e403df040e69ca}\label{class_lora_mesher_ac3807f4ae5e6fa40e7e403df040e69ca}} 
\index{LoraMesher@{LoraMesher}!init@{init}}
\index{init@{init}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{init()}{init()}}
{\footnotesize\ttfamily void Lora\+Mesher\+::init (\begin{DoxyParamCaption}\item[{void($\ast$)(void $\ast$)}]{receiver\+Function }\end{DoxyParamCaption})}



Initialize the Lora Mesher object. 


\begin{DoxyParams}{Parameters}
{\em receiver\+Function} & Receiver function. It will be notified when data for the user is habailable.\\
\hline
\end{DoxyParams}
Example of usage\+:~\newline

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} processReceivedPackets(\textcolor{keywordtype}{void}* parameters) \{}
\DoxyCodeLine{     \textcolor{keywordflow}{for} (;;) \{}
\DoxyCodeLine{         \textcolor{comment}{//Wait for the notification of processReceivedPackets and enter blocking}}
\DoxyCodeLine{         ulTaskNotifyTake(pdPASS, portMAX\_DELAY);}
\DoxyCodeLine{}
\DoxyCodeLine{         \textcolor{comment}{//Iterate through all the received queue size}}
\DoxyCodeLine{         \textcolor{keywordflow}{while} (radio.getReceivedQueueSize() > 0) \{}
\DoxyCodeLine{             \textcolor{comment}{//Get the first element of the queue}}
\DoxyCodeLine{             \mbox{\hyperlink{struct_lora_mesher_1_1user_packet}{LoraMesher::userPacket<dataPacket>}}* packet = radio.getNextUserPacket<\mbox{\hyperlink{structdata_packet}{dataPacket}}>();}
\DoxyCodeLine{}
\DoxyCodeLine{             \textcolor{comment}{//Do something with the packet, ex: print(packetReceived);}}
\DoxyCodeLine{}
\DoxyCodeLine{             \textcolor{comment}{//Delete the packet when used. It is very important to call this function to release the memory of the packet.}}
\DoxyCodeLine{             radio.deletePacket(packet);}
\DoxyCodeLine{         \}}
\DoxyCodeLine{     \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


Then initialize\+:~\newline

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{class_lora_mesher}{LoraMesher}} radio = \mbox{\hyperlink{class_lora_mesher_a7b71856ecfaa71d694fb008c0ba4642a}{LoraMesher::getInstance}}();}
\DoxyCodeLine{radio.\mbox{\hyperlink{class_lora_mesher_ac3807f4ae5e6fa40e7e403df040e69ca}{init}}(processReceivedPackets);}

\end{DoxyCode}
 \mbox{\Hypertarget{class_lora_mesher_ab70a80c723b4a610b897fd8f523a3359}\label{class_lora_mesher_ab70a80c723b4a610b897fd8f523a3359}} 
\index{LoraMesher@{LoraMesher}!routingTableSize@{routingTableSize}}
\index{routingTableSize@{routingTableSize}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{routingTableSize()}{routingTableSize()}}
{\footnotesize\ttfamily int Lora\+Mesher\+::routing\+Table\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Returns the routing table size. 

\begin{DoxyReturn}{Returns}
int
\end{DoxyReturn}
End Region Packet Service Region Routing Table \mbox{\Hypertarget{class_lora_mesher_afd00da774300a17399cbee5941ebc934}\label{class_lora_mesher_afd00da774300a17399cbee5941ebc934}} 
\index{LoraMesher@{LoraMesher}!sendReliable@{sendReliable}}
\index{sendReliable@{sendReliable}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{sendReliable()}{sendReliable()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Lora\+Mesher\+::send\+Reliable (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{dst,  }\item[{T $\ast$}]{payload,  }\item[{uint32\+\_\+t}]{payload\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Send the payload reliable. It will wait for an ack of the destination. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em dst} & Destination \\
\hline
{\em payload} & Payload of type T \\
\hline
{\em payload\+Size} & Length of the payload in T \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_lora_mesher_a129d8a250d3b7dce85f735d6313fb256}\label{class_lora_mesher_a129d8a250d3b7dce85f735d6313fb256}} 
\index{LoraMesher@{LoraMesher}!sendReliablePacket@{sendReliablePacket}}
\index{sendReliablePacket@{sendReliablePacket}!LoraMesher@{LoraMesher}}
\doxysubsubsection{\texorpdfstring{sendReliablePacket()}{sendReliablePacket()}}
{\footnotesize\ttfamily void Lora\+Mesher\+::send\+Reliable\+Packet (\begin{DoxyParamCaption}\item[{uint16\+\_\+t}]{dst,  }\item[{uint8\+\_\+t $\ast$}]{payload,  }\item[{uint32\+\_\+t}]{payload\+Size }\end{DoxyParamCaption})}



Send the payload reliable. It will wait for an ACK back from the destination to send the next packet. 


\begin{DoxyParams}{Parameters}
{\em dst} & destination address \\
\hline
{\em payload} & payload to send \\
\hline
{\em payload\+Size} & payload size to be send in Bytes \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/janm2/\+Documents/\+Platform\+IO/\+Projects/\+Gps\+And\+Display/.\+pio/libdeps/ttgo-\/t-\/beam/\+Lo\+Ra\+Mesher/src/loramesher.\+h\item 
C\+:/\+Users/janm2/\+Documents/\+Platform\+IO/\+Projects/\+Gps\+And\+Display/.\+pio/libdeps/ttgo-\/t-\/beam/\+Lo\+Ra\+Mesher/src/loramesher.\+cpp\end{DoxyCompactItemize}
